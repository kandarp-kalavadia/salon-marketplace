To manage different panels (`AdminPanel`, `SalonOwnerPanel`, `CustomerPanel`) with additional menu items (e.g., for `SalonOwnerPanel`: Bookings, Transactions, Payments, Category, Services) in your React app, you need to implement **routing** to navigate between these menu items and **permission checks** to ensure users can only access features corresponding to their roles (`Admin`, `Salon Owner`, `Customer`). This solution will extend the existing React setup (using Vite, Material UI, Tailwind CSS, and `oidc-client-ts` for Keycloak authentication) to include nested routing for menu items and role-based access control, following industry-standard practices and leveraging modern React tools.

---

### **Requirements Recap**
- **Panels and Menu Items**:
  - `AdminPanel`: Manage admin-specific data (e.g., users, reports).
  - `SalonOwnerPanel`: Menu items for Bookings, Transactions, Payments, Category, Services.
  - `CustomerPanel`: Menu items for searching salons, booking services, viewing bookings.
- **Routing**: Each panel should have its own route with nested routes for menu items (e.g., `/salon-owner/bookings`, `/salon-owner/services`).
- **Permissions**: Restrict access to panels and menu items based on Keycloak roles (`Admin`, `Salon Owner`, `Customer`).
- **Tech Stack**: React with Vite, Material UI, Tailwind CSS, TypeScript, `react-router-dom`, and Keycloak for authentication.
- **Integration**: The solution should work with your existing Spring Boot microservices, Keycloak setup, and Docker Compose configuration.

---

### **Solution Overview**
1. **Routing**:
   - Use `react-router-dom` to create nested routes for each panel.
   - Define routes like `/salon-owner/bookings`, `/salon-owner/services`, etc., under the respective panel routes.
   - Implement a sidebar or top navigation menu in each panel to access menu items.

2. **Permissions**:
   - Leverage Keycloak’s access token, which includes the `roles` claim (e.g., `["Customer"]`, `["Salon Owner"]`), to enforce role-based access.
   - Create a `ProtectedRoute` component to check roles before rendering a panel or menu item.
   - Display an “Unauthorized” message or redirect to a fallback page for unauthorized access.

3. **UI**:
   - Use Material UI’s `Drawer` for a sidebar menu in each panel.
   - Style with Tailwind CSS for consistency and responsiveness.
   - Ensure the UI is modular and reusable.

4. **Integration**:
   - Call protected Spring Boot APIs (via the gateway at `http://localhost:8082`) for each menu item, using the Keycloak access token in the `Authorization` header.
   - Maintain compatibility with the existing `AuthContext` and Keycloak setup.

---

### **Step-by-Step Implementation**

#### **1. Update Project Structure**
Extend the existing React project structure to include new components for menu items and a shared layout for panels.

```
react-app/
├── src/
│   ├── assets/
│   ├── components/
│   │   ├── CustomerSignupForm.tsx
│   │   ├── SalonOwnerSignupForm.tsx
│   │   ├── AdminPanel.tsx
│   │   ├── SalonOwnerPanel.tsx
│   │   ├── CustomerPanel.tsx
│   │   ├── PanelLayout.tsx
│   │   ├── salon-owner/
│   │   │   ├── Bookings.tsx
│   │   │   ├── Transactions.tsx
│   │   │   ├── Payments.tsx
│   │   │   ├── Category.tsx
│   │   │   ├── Services.tsx
│   │   ├── admin/
│   │   │   ├── Users.tsx
│   │   │   ├── Reports.tsx
│   │   ├── customer/
│   │   │   ├── SearchSalons.tsx
│   │   │   ├── BookService.tsx
│   │   │   ├── MyBookings.tsx
│   ├── context/
│   │   ├── AuthContext.tsx
│   ├── pages/
│   │   ├── Home.tsx
│   │   ├── Callback.tsx
│   │   ├── Unauthorized.tsx
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
├── tailwind.config.js
├── vite.config.ts
├── package.json
```

---

#### **2. Update Keycloak Configuration**
Ensure the Keycloak access token includes the `roles` claim, which was already configured in the previous setup (`react-app` client > `Client Scopes` > `react-app-dedicated` > `Mappers` > `realm roles`). Verify:
- Mapper Name: `realm roles`
- Token Claim Name: `roles`
- Add to ID token: `true`
- Add to access token: `true`

This ensures the access token contains the user’s roles (e.g., `["Customer"]`, `["Salon Owner"]`, `["Admin"]`) in the `roles` claim.

---

#### **3. Update React Code**

1. **Create a Protected Route Component**:
   This component checks the user’s roles before rendering a panel or menu item.

   ```tsx
   // react-app/src/components/ProtectedRoute.tsx
   import { useContext } from 'react';
   import { Navigate } from 'react-router-dom';
   import { AuthContext } from '../context/AuthContext';

   interface ProtectedRouteProps {
     allowedRoles: string[];
     children: React.ReactNode;
   }

   const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ allowedRoles, children }) => {
     const { user, loading } = useContext(AuthContext);

     if (loading) return <div>Loading...</div>;

     if (!user || !allowedRoles.some((role) => user.profile.roles.includes(role))) {
       return <Navigate to="/unauthorized" replace />;
     }

     return <>{children}</>;
   };

   export default ProtectedRoute;
   ```

2. **Create a Panel Layout Component**:
   This component provides a common layout with a sidebar menu for each panel.

   ```tsx
   // react-app/src/components/PanelLayout.tsx
   import { useState, useContext } from 'react';
   import { Drawer, List, ListItem, ListItemText, Toolbar, AppBar, Typography, IconButton, Box } from '@mui/material';
   import MenuIcon from '@mui/icons-material/Menu';
   import { Link, useLocation } from 'react-router-dom';
   import { AuthContext } from '../context/AuthContext';

   interface PanelLayoutProps {
     title: string;
     menuItems: { label: string; path: string }[];
     children: React.ReactNode;
   }

   const PanelLayout: React.FC<PanelLayoutProps> = ({ title, menuItems, children }) => {
     const { logout } = useContext(AuthContext);
     const [mobileOpen, setMobileOpen] = useState(false);
     const location = useLocation();

     const handleDrawerToggle = () => {
       setMobileOpen(!mobileOpen);
     };

     const drawer = (
       <div>
         <Toolbar />
         <List>
           {menuItems.map((item) => (
             <ListItem
               key={item.path}
               component={Link}
               to={item.path}
               selected={location.pathname === item.path}
               className="hover:bg-gray-100"
             >
               <ListItemText primary={item.label} />
             </ListItem>
           ))}
           <ListItem component={Link} to="/" onClick={logout} className="hover:bg-gray-100">
             <ListItemText primary="Logout" />
           </ListItem>
         </List>
       </div>
     );

     return (
       <Box sx={{ display: 'flex' }}>
         <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
           <Toolbar>
             <IconButton
               color="inherit"
               aria-label="open drawer"
               edge="start"
               onClick={handleDrawerToggle}
               sx={{ mr: 2, display: { sm: 'none' } }}
             >
               <MenuIcon />
             </IconButton>
             <Typography variant="h6" noWrap component="div">
               {title}
             </Typography>
           </Toolbar>
         </AppBar>
         <Box
           component="nav"
           sx={{ width: { sm: 240 }, flexShrink: { sm: 0 } }}
           aria-label="menu items"
         >
           <Drawer
             variant="temporary"
             open={mobileOpen}
             onClose={handleDrawerToggle}
             ModalProps={{ keepMounted: true }}
             sx={{
               display: { xs: 'block', sm: 'none' },
               '& .MuiDrawer-paper': { boxSizing: 'border-box', width: 240 },
             }}
           >
             {drawer}
           </Drawer>
           <Drawer
             variant="permanent"
             sx={{
               display: { xs: 'none', sm: 'block' },
               '& .MuiDrawer-paper': { boxSizing: 'border-box', width: 240 },
             }}
             open
           >
             {drawer}
           </Drawer>
         </Box>
         <Box component="main" sx={{ flexGrow: 1, p: 3 }}>
           <Toolbar />
           {children}
         </Box>
       </Box>
     );
   };

   export default PanelLayout;
   ```

3. **Update Panel Components**:
   Replace the existing panel components with versions that use `PanelLayout` and nested routes.

   ```tsx
   // react-app/src/components/AdminPanel.tsx
   import { Routes, Route } from 'react-router-dom';
   import PanelLayout from './PanelLayout';
   import Users from './admin/Users';
   import Reports from './admin/Reports';

   const AdminPanel: React.FC = () => {
     const menuItems = [
       { label: 'Users', path: '/admin/users' },
       { label: 'Reports', path: '/admin/reports' },
     ];

     return (
       <PanelLayout title="Admin Panel" menuItems={menuItems}>
         <Routes>
           <Route path="users" element={<Users />} />
           <Route path="reports" element={<Reports />} />
           <Route index element={<div>Select a menu item</div>} />
         </Routes>
       </PanelLayout>
     );
   };

   export default AdminPanel;
   ```

   ```tsx
   // react-app/src/components/SalonOwnerPanel.tsx
   import { Routes, Route } from 'react-router-dom';
   import PanelLayout from './PanelLayout';
   import Bookings from './salon-owner/Bookings';
   import Transactions from './salon-owner/Transactions';
   import Payments from './salon-owner/Payments';
   import Category from './salon-owner/Category';
   import Services from './salon-owner/Services';

   const SalonOwnerPanel: React.FC = () => {
     const menuItems = [
       { label: 'Bookings', path: '/salon-owner/bookings' },
       { label: 'Transactions', path: '/salon-owner/transactions' },
       { label: 'Payments', path: '/salon-owner/payments' },
       { label: 'Category', path: '/salon-owner/category' },
       { label: 'Services', path: '/salon-owner/services' },
     ];

     return (
       <PanelLayout title="Salon Owner Panel" menuItems={menuItems}>
         <Routes>
           <Route path="bookings" element={<Bookings />} />
           <Route path="transactions" element={<Transactions />} />
           <Route path="payments" element={<Payments />} />
           <Route path="category" element={<Category />} />
           <Route path="services" element={<Services />} />
           <Route index element={<div>Select a menu item</div>} />
         </Routes>
       </PanelLayout>
     );
   };

   export default SalonOwnerPanel;
   ```

   ```tsx
   // react-app/src/components/CustomerPanel.tsx
   import { Routes, Route } from 'react-router-dom';
   import PanelLayout from './PanelLayout';
   import SearchSalons from './customer/SearchSalons';
   import BookService from './customer/BookService';
   import MyBookings from './customer/MyBookings';

   const CustomerPanel: React.FC = () => {
     const menuItems = [
       { label: 'Search Salons', path: '/customer/search-salons' },
       { label: 'Book Service', path: '/customer/book-service' },
       { label: 'My Bookings', path: '/customer/my-bookings' },
     ];

     return (
       <PanelLayout title="Customer Panel" menuItems={menuItems}>
         <Routes>
           <Route path="search-salons" element={<SearchSalons />} />
           <Route path="book-service" element={<BookService />} />
           <Route path="my-bookings" element={<MyBookings />} />
           <Route index element={<div>Select a menu item</div>} />
         </Routes>
       </PanelLayout>
     );
   };

   export default CustomerPanel;
   ```

4. **Create Menu Item Components**:
   Implement placeholder components for each menu item. You can extend these with API calls and specific functionality later.

   ```tsx
   // react-app/src/components/admin/Users.tsx
   import { Button } from '@mui/material';
   import { useContext } from 'react';
   import { AuthContext } from '../../context/AuthContext';

   const Users: React.FC = () => {
     const { getToken } = useContext(AuthContext);

     const fetchUsers = async () => {
       try {
         const token = getToken();
         const response = await fetch('http://localhost:8082/api/protected', {
           headers: {
             Authorization: `Bearer ${token}`,
           },
         });
         const data = await response.text();
         console.log('Protected API response:', data);
       } catch (error) {
         console.error('API error:', error);
       }
     };

     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Manage Users</h2>
         <Button variant="contained" onClick={fetchUsers}>
           Fetch Users
         </Button>
       </div>
     );
   };

   export default Users;
   ```

   ```tsx
   // react-app/src/components/admin/Reports.tsx
   import { Button } from '@mui/material';

   const Reports: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Reports</h2>
         <Button variant="contained">Generate Report</Button>
       </div>
     );
   };

   export default Reports;
   ```

   ```tsx
   // react-app/src/components/salon-owner/Bookings.tsx
   import { Button } from '@mui/material';

   const Bookings: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Bookings</h2>
         <Button variant="contained">View Bookings</Button>
       </div>
     );
   };

   export default Bookings;
   ```

   ```tsx
   // react-app/src/components/salon-owner/Transactions.tsx
   import { Button } from '@mui/material';

   const Transactions: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Transactions</h2>
         <Button variant="contained">View Transactions</Button>
       </div>
     );
   };

   export default Transactions;
   ```

   ```tsx
   // react-app/src/components/salon-owner/Payments.tsx
   import { Button } from '@mui/material';

   const Payments: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Payments</h2>
         <Button variant="contained">Manage Payments</Button>
       </div>
     );
   };

   export default Payments;
   ```

   ```tsx
   // react-app/src/components/salon-owner/Category.tsx
   import { Button } from '@mui/material';

   const Category: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Categories</h2>
         <Button variant="contained">Add Category</Button>
       </div>
     );
   };

   export default Category;
   ```

   ```tsx
   // react-app/src/components/salon-owner/Services.tsx
   import { Button } from '@mui/material';

   const Services: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Services</h2>
         <Button variant="contained">Add Service</Button>
       </div>
     );
   };

   export default Services;
   ```

   ```tsx
   // react-app/src/components/customer/SearchSalons.tsx
   import { Button } from '@mui/material';

   const SearchSalons: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Search Salons</h2>
         <Button variant="contained">Search</Button>
       </div>
     );
   };

   export default SearchSalons;
   ```

   ```tsx
   // react-app/src/components/customer/BookService.tsx
   import { Button } from '@mui/material';

   const BookService: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">Book Service</h2>
         <Button variant="contained">Book Now</Button>
       </div>
     );
   };

   export default BookService;
   ```

   ```tsx
   // react-app/src/components/customer/MyBookings.tsx
   import { Button } from '@mui/material';

   const MyBookings: React.FC = () => {
     return (
       <div className="p-4">
         <h2 className="text-xl font-semibold">My Bookings</h2>
         <Button variant="contained">View Bookings</Button>
       </div>
     );
   };

   export default MyBookings;
   ```

5. **Create Unauthorized Page**:
   ```tsx
   // react-app/src/pages/Unauthorized.tsx
   import { Button } from '@mui/material';
   import { Link } from 'react-router-dom';

   const Unauthorized: React.FC = () => {
     return (
       <div className="p-4 text-center">
         <h1 className="text-3xl font-bold text-red-600">Unauthorized</h1>
         <p className="mt-4">You do not have permission to access this page.</p>
         <Button variant="contained" component={Link} to="/" className="mt-4">
           Back to Home
         </Button>
       </div>
     );
   };

   export default Unauthorized;
   ```

6. **Update App Component**:
   Modify `App.tsx` to use `ProtectedRoute` for role-based access and include nested routes.

   ```tsx
   // react-app/src/App.tsx
   import { Routes, Route } from 'react-router-dom';
   import Home from './pages/Home';
   import Callback from './pages/Callback';
   import Unauthorized from './pages/Unauthorized';
   import AdminPanel from './components/AdminPanel';
   import SalonOwnerPanel from './components/SalonOwnerPanel';
   import CustomerPanel from './components/CustomerPanel';
   import ProtectedRoute from './components/ProtectedRoute';

   function App() {
     return (
       <Routes>
         <Route path="/" element={<Home />} />
         <Route path="/callback" element={<Callback />} />
         <Route path="/unauthorized" element={<Unauthorized />} />
         <Route
           path="/admin/*"
           element={
             <ProtectedRoute allowedRoles={['Admin']}>
               <AdminPanel />
             </ProtectedRoute>
           }
         />
         <Route
           path="/salon-owner/*"
           element={
             <ProtectedRoute allowedRoles={['Salon Owner']}>
               <SalonOwnerPanel />
             </ProtectedRoute>
           }
         />
         <Route
           path="/customer/*"
           element={
             <ProtectedRoute allowedRoles={['Customer']}>
               <CustomerPanel />
             </ProtectedRoute>
           }
         />
       </Routes>
     );
   }

   export default App;
   ```

7. **Update AuthContext**:
   Ensure the `AuthContext` correctly parses the `roles` claim from the Keycloak token. Modify the `user` object to include `profile.roles`.

   ```tsx
   // react-app/src/context/AuthContext.tsx
   import React, { createContext, useEffect, useState } from 'react';
   import { UserManager, WebStorageStateStore } from 'oidc-client-ts';

   interface AuthContextType {
     user: any | null;
     login: () => void;
     logout: () => void;
     getToken: () => string | null;
     loading: boolean;
   }

   export const AuthContext = createContext<AuthContextType | undefined>(undefined);

   const userManager = new UserManager({
     authority: 'http://localhost:8080/realms/salon-realm',
     client_id: 'react-app',
     redirect_uri: 'http://localhost:3000/callback',
     response_type: 'code',
     scope: 'openid profile email roles',
     post_logout_redirect_uri: 'http://localhost:3000',
     automaticSilentRenew: true,
     userStore: new WebStorageStateStore({ store: window.localStorage }),
   });

   export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
     const [user, setUser] = useState<any | null>(null);
     const [loading, setLoading] = useState(true);

     useEffect(() => {
       userManager.getUser().then((user) => {
         if (user) {
           // Parse roles from the access token
           const roles = user.profile.roles || [];
           setUser({ ...user, profile: { ...user.profile, roles } });
         }
         setLoading(false);
       });

       userManager.events.addUserLoaded((user) => {
         const roles = user.profile.roles || [];
         setUser({ ...user, profile: { ...user.profile, roles } });
       });
       userManager.events.addUserUnloaded(() => setUser(null));
       userManager.events.addAccessTokenExpired(() => userManager.signinRedirect());
     }, []);

     const login = () => userManager.signinRedirect();
     const logout = () => userManager.signoutRedirect();
     const getToken = () => user?.access_token || null;

     return (
       <AuthContext.Provider value={{ user, login, logout, getToken, loading }}>
         {children}
       </AuthContext.Provider>
     );
   };
   ```

---

#### **4. Update Spring Boot Backend**
Ensure the backend APIs are role-protected and accessible via the gateway. The existing `salon-user` service already has a `/api/protected` endpoint. Add role-based access control using Spring Security.

1. **Update SecurityConfig**:
   Modify `salon-user/src/main/java/com/salon/user/SecurityConfig.java` to restrict endpoints by role.

   ```java
   package com.salon.user;

   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
   import org.springframework.security.web.SecurityFilterChain;

   @Configuration
   @EnableWebSecurity
   public class SecurityConfig {

       @Bean
       public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
           http
               .authorizeHttpRequests(auth -> auth
                   .requestMatchers("/api/users/**").permitAll()
                   .requestMatchers("/api/protected/**").hasAnyAuthority("Customer", "Salon Owner", "Admin")
                   .anyRequest().authenticated()
               )
               .oauth2ResourceServer(oauth2 -> oauth2.jwt());
           return http.build();
       }
   }
   ```

2. **Add Role-Specific Endpoints**:
   Extend `ProtectedController` to include endpoints for each menu item.

   ```java
   // salon-user/src/main/java/com/salon/user/controller/ProtectedController.java
   package com.salon.user.controller;

   import org.springframework.security.core.annotation.AuthenticationPrincipal;
   import org.springframework.security.oauth2.jwt.Jwt;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;

   @RestController
   @RequestMapping("/api/protected")
   public class ProtectedController {

       @GetMapping
       public String protectedEndpoint(@AuthenticationPrincipal Jwt jwt) {
           return "Hello, " + jwt.getClaim("preferred_username") + "! Role: " + jwt.getClaim("roles");
       }

       @GetMapping("/admin/users")
       public String manageUsers(@AuthenticationPrincipal Jwt jwt) {
           return "Admin: Managing users for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/admin/reports")
       public String generateReports(@AuthenticationPrincipal Jwt jwt) {
           return "Admin: Generating reports for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/salon-owner/bookings")
       public String viewBookings(@AuthenticationPrincipal Jwt jwt) {
           return "Salon Owner: Viewing bookings for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/salon-owner/transactions")
       public String viewTransactions(@AuthenticationPrincipal Jwt jwt) {
           return "Salon Owner: Viewing transactions for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/salon-owner/payments")
       public String managePayments(@AuthenticationPrincipal Jwt jwt) {
           return "Salon Owner: Managing payments for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/salon-owner/category")
       public String manageCategories(@AuthenticationPrincipal Jwt jwt) {
           return "Salon Owner: Managing categories for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/salon-owner/services")
       public String manageServices(@AuthenticationPrincipal Jwt jwt) {
           return "Salon Owner: Managing services for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/customer/search-salons")
       public String searchSalons(@AuthenticationPrincipal Jwt jwt) {
           return "Customer: Searching salons for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/customer/book-service")
       public String bookService(@AuthenticationPrincipal Jwt jwt) {
           return "Customer: Booking service for " + jwt.getClaim("preferred_username");
       }

       @GetMapping("/customer/my-bookings")
       public String viewMyBookings(@AuthenticationPrincipal Jwt jwt) {
           return "Customer: Viewing bookings for " + jwt.getClaim("preferred_username");
       }
   }
   ```

3. **Update Gateway Routes**:
   Ensure the gateway routes these endpoints correctly. The existing `salon-gateway/src/main/resources/application.yml` is sufficient:
   ```yaml
   spring:
     cloud:
       gateway:
         routes:
           - id: user-service
             uri: lb://user-service
             predicates:
               - Path=/api/users/**
           - id: protected-service
             uri: lb://user-service
             predicates:
               - Path=/api/protected/**
   ```

---

#### **5. Update Docker Compose**
The existing `docker-compose.yml` is sufficient, as it includes Keycloak, Papercut, Eureka, Gateway, User Service, and React App. Ensure all services are running in the `salon-network` and ports are correctly mapped.

---

#### **6. Testing the Application**
1. **Start Services**:
   ```bash
   docker-compose up
   ```

2. **Sign Up**:
   - Open `http://localhost:3000`.
   - Create a `Customer`, `Salon Owner`, and `Admin` user via the signup forms.
   - Verify users in Keycloak (`http://localhost:8080/admin`).

3. **Log In**:
   - Click “Login” and authenticate with Keycloak (username, password, email OTP via Papercut at `http://localhost:8081`).
   - Verify redirection to the appropriate panel based on role.

4. **Test Routing and Permissions**:
   - **Admin**:
     - Navigate to `http://localhost:3000/admin`.
     - Access `/admin/users` and `/admin/reports` via the sidebar.
     - Try accessing `/salon-owner/bookings` (should redirect to `/unauthorized`).
   - **Salon Owner**:
     - Navigate to `http://localhost:3000/salon-owner`.
     - Access `/salon-owner/bookings`, `/salon-owner/transactions`, etc.
     - Try accessing `/admin/users` (should redirect to `/unauthorized`).
   - **Customer**:
     - Navigate to `http://localhost:3000/customer`.
     - Access `/customer/search-salons`, `/customer/book-service`, etc.
     - Try accessing `/salon-owner/bookings` (should redirect to `/unauthorized`).

5. **Test API Calls**:
   - In each menu item component (e.g., `Bookings.tsx`), call the corresponding backend API (e.g., `http://localhost:8082/api/protected/salon-owner/bookings`) using the access token.
   - Verify the response includes the username and role.

---

### **Security and Best Practices**
1. **Role-Based Access**:
   - The `ProtectedRoute` component ensures only users with the correct roles access panels and menu items.
   - Backend endpoints are protected with `hasAnyAuthority`, ensuring role consistency between frontend and backend.

2. **Token Security**:
   - Tokens are stored in `localStorage` by `oidc-client-ts`. For production, use `HttpOnly` cookies or in-memory storage:
     ```tsx
     // react-app/src/context/AuthContext.tsx
     userStore: new WebStorageStateStore({ store: window.sessionStorage }), // Use sessionStorage
     ```
   - Use HTTPS to secure token transmission.

3. **Routing**:
   - Nested routes (`/salon-owner/*`) keep the routing structure clean and modular.
   - The `PanelLayout` component provides a reusable UI for all panels.

4. **UI**:
   - Material UI’s `Drawer` and `AppBar` ensure a responsive and professional interface.
   - Tailwind CSS classes enhance styling flexibility.

5. **Error Handling**:
   - Handle API errors in menu item components:
     ```tsx
     const fetchBookings = async () => {
       try {
         const token = getToken();
         const response = await fetch('http://localhost:8082/api/protected/salon-owner/bookings', {
           headers: { Authorization: `Bearer ${token}` },
         });
         if (!response.ok) throw new Error('API error');
         const data = await response.text();
         console.log(data);
       } catch (error) {
         console.error('Fetch bookings error:', error);
       }
     };
     ```

6. **Performance**:
   - Use React’s `useMemo` or `useCallback` for expensive computations or callbacks in menu item components.
   - Lazy-load panel components if they grow large:
     ```tsx
     const Bookings = React.lazy(() => import('./salon-owner/Bookings'));
     ```

---

### **Extending the Solution**
To implement the actual functionality for each menu item:
1. **Backend APIs**:
   - Add services and repositories in `salon-user` to handle bookings, transactions, etc.
   - Example for Bookings:
     ```java
     @GetMapping("/salon-owner/bookings")
     public List<Booking> getBookings(@AuthenticationPrincipal Jwt jwt) {
         // Fetch bookings from database for the salon owner
         return bookingService.getBookingsBySalonOwner(jwt.getClaim("sub"));
     }
     ```

2. **Frontend Data Fetching**:
   - Update components like `Bookings.tsx` to fetch and display data:
     ```tsx
     const Bookings: React.FC = () => {
       const { getToken } = useContext(AuthContext);
       const [bookings, setBookings] = useState([]);

       useEffect(() => {
         const fetchBookings = async () => {
           const token = getToken();
           const response = await fetch('http://localhost:8082/api/protected/salon-owner/bookings', {
             headers: { Authorization: `Bearer ${token}` },
           });
           const data = await response.json();
           setBookings(data);
         };
         fetchBookings();
       }, [getToken]);

       return (
         <div className="p-4">
           <h2 className="text-xl font-semibold">Bookings</h2>
           <ul>
             {bookings.map((booking) => (
               <li key={booking.id}>{booking.date} - {booking.service}</li>
             ))}
           </ul>
         </div>
       );
     };
     ```

3. **Database Integration**:
   - Add a database (e.g., MySQL) to your Docker Compose setup and configure `salon-user` to store salon, booking, and service data.

---

### **Artifact**
```typescript
```tsx
import { useState, useContext } from 'react';
import { Drawer, List, ListItem, ListItemText, Toolbar, AppBar, Typography, IconButton, Box } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { Link, useLocation } from 'react-router-dom';
import { AuthContext } from '../context/AuthContext';

interface PanelLayoutProps {
  title: string;
  menuItems: { label: string; path: string }[];
  children: React.ReactNode;
}

const PanelLayout: React.FC<PanelLayoutProps> = ({ title, menuItems, children }) => {
  const { logout } = useContext(AuthContext);
  const [mobileOpen, setMobileOpen] = useState(false);
  const location = useLocation();

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const drawer = (
    <div>
      <Toolbar />
      <List>
        {menuItems.map((item) => (
          <ListItem
            key={item.path}
            component={Link}
            to={item.path}
            selected={location.pathname === item.path}
            className="hover:bg-gray-100"
          >
            <ListItemText primary={item.label} />
          </ListItem>
        ))}
        <ListItem component={Link} to="/" onClick={logout} className="hover:bg-gray-100">
          <ListItemText primary="Logout" />
        </ListItem>
      </List>
    </div>
  );

  return (
    <Box sx={{ display: 'flex' }}>
      <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2, display: { sm: 'none' } }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" noWrap component="div">
            {title}
          </Typography>
        </Toolbar>
      </AppBar>
      <Box
        component="nav"
        sx={{ width: { sm: 240 }, flexShrink: { sm: 0 } }}
        aria-label="menu items"
      >
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{ keepMounted: true }}
          sx={{
            display: { xs: 'block', sm: 'none' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: 240 },
          }}
        >
          {drawer}
        </Drawer>
        <Drawer
          variant="permanent"
          sx={{
            display: { xs: 'none', sm: 'block' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: 240 },
          }}
          open
        >
          {drawer}
        </Drawer>
      </Box>
      <Box component="main" sx={{ flexGrow: 1, p: 3 }}>
        <Toolbar />
        {children}
      </Box>
    </Box>
  );
};

export default PanelLayout;
```
```

---

### **Summary**
- **Routing**: Nested routes (`/salon-owner/bookings`, `/admin/users`, etc.) are managed using `react-router-dom` within each panel, with a `PanelLayout` component providing a consistent sidebar menu.
- **Permissions**: The `ProtectedRoute` component checks Keycloak roles before rendering panels or menu items, redirecting unauthorized users to `/unauthorized`.
- **UI**: Material UI’s `Drawer` and `AppBar` create a responsive sidebar, styled with Tailwind CSS.
- **Backend**: Role-protected endpoints in `salon-user` ensure only authorized users access specific features.
- **Testing**: Verify role-based access, navigation, and API calls for each panel and menu item.

This solution is modular, secure, and extensible, allowing you to add functionality (e.g., database integration, complex UI) to each menu item. If you need specific API implementations, additional UI components, or help with debugging, let me know!