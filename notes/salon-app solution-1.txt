Let’s create a comprehensive solution for your requirements, starting from scratch. You want to build a Spring Boot microservices architecture with a gateway, integrated with Keycloak for authentication (including multifactor authentication via email OTP using Papercut for local development), and a React frontend using Material UI, Tailwind CSS, and Vite. The system will support three roles (`Customer`, `Salon Owner`, `Admin`), each with distinct frontend panels, and handle signup via Spring Boot and login via Keycloak. I’ll provide all necessary Keycloak configurations, Spring Boot backend code, and a modern React setup following industry standards and best practices.

---

### **Requirements Summary**
1. **Backend**:
   - Spring Boot microservices with a gateway (e.g., Spring Cloud Gateway).
   - Signup API in Spring Boot to create users (`Customer` and `Salon Owner`) in Keycloak.
   - Keycloak integration for login with multifactor authentication (email OTP using Papercut locally).
   - Roles: `Customer`, `Salon Owner`, `Admin`.

2. **Keycloak**:
   - Latest version (26.0.2 as of April 2025).
   - Configure a realm, clients, roles, and email OTP MFA.
   - Use Papercut for local email testing.

3. **Frontend**:
   - React app using Vite, Material UI, and Tailwind CSS.
   - Role-based UI:
     - **Admin**: Admin panel for admin-related data.
     - **Salon Owner**: Manage salon categories and services.
     - **Customer/Guest**: Search salons and book services (login required for booking).
   - Two signup forms (Customer and Salon Owner, basic setup).
   - Industry-standard setup with best practices (e.g., TypeScript, ESLint, Prettier, modular structure).

4. **Authentication Flow**:
   - **Signup**: Handled by Spring Boot API, creating users in Keycloak with appropriate roles.
   - **Login**: Handled by Keycloak using Authorization Code Flow with PKCE, including email OTP MFA.
   - **Token Management**: Access and refresh tokens passed to React app for authenticated API calls.

---

### **Step-by-Step Solution**

#### **1. Keycloak Configuration**
We’ll configure Keycloak 26.0.2 with a realm, clients, roles, and email OTP MFA using Papercut for local email testing.

1. **Run Keycloak Locally**:
   Use Docker to start Keycloak:
   ```bash
   docker run -p 8080:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:26.0.2 start-dev
   ```

2. **Run Papercut for Email Testing**:
   Papercut is a simple SMTP server for local email testing.
   ```bash
   docker run -p 25:25 -p 8081:8080 jijiechen/papercut:latest
   ```
   - Access Papercut UI at `http://localhost:8081` to view sent emails.
   - SMTP server runs on `localhost:25`.

3. **Configure Keycloak**:
   Log in to the Keycloak Admin Console (`http://localhost:8080/admin`) with `admin/admin`.

   a. **Create a Realm**:
   - Go to the realm dropdown (top-left) and click “Create Realm”.
   - Name: `salon-realm`.
   - Save.

   b. **Create Roles**:
   - Go to `Realm Roles` > `Create Role`.
   - Create three roles:
     - `Customer`
     - `Salon Owner`
     - `Admin`
   - Save each role.

   c. **Create Clients**:
   - Go to `Clients` > `Create Client`.
   - **Backend Admin Client** (for Spring Boot signup):
     - Client ID: `spring-boot-admin`
     - Client Protocol: `openid-connect`
     - Access Type: `Confidential`
     - Standard Flow Enabled: `false` (no login, only admin operations)
     - Service Accounts Enabled: `true`
     - Save.
     - Go to `Credentials` tab, copy the **Client Secret**.
     - Go to `Service Account Roles` tab, assign `manage-users` and `query-users` from the `realm-management` client.
   - **React App Client** (for login):
     - Client ID: `react-app`
     - Client Protocol: `openid-connect`
     - Access Type: `Public`
     - Standard Flow Enabled: `true`
     - Valid Redirect URIs: `http://localhost:3000/*`
     - Web Origins: `http://localhost:3000`
     - Save.
     - Go to `Client Scopes` > `react-app-dedicated` > `Mappers` > `Create Protocol Mapper`:
       - Name: `realm roles`
       - Mapper Type: `User Realm Role`
       - Token Claim Name: `roles`
       - Add to ID token: `true`
       - Add to access token: `true`
       - Save.

   d. **Configure Email Settings**:
   - Go to `Realm Settings` > `Email` tab.
   - Host: `papercut` (or `localhost` if running locally without Docker networking).
   - Port: `25`
   - From: `no-reply@salon-app.com`
   - Enable SSL/TLS: `false` (Papercut doesn’t require it).
   - Save.
   - Test connection to ensure Keycloak can send emails to Papercut.

   e. **Configure Email OTP MFA**:
   - Go to `Authentication` > `Flows` tab.
   - Click `Create Flow`:
     - Name: `Browser with Email OTP`
     - Flow Type: `Generic`
   - Add executions:
     - `Username Password Form` (Required)
     - `OTP Form` (Required)
       - Click `Configure` > `Email OTP` (configure if needed, defaults are fine for Papercut).
   - Bind the flow:
     - Go to `Bindings` tab.
     - Set `Browser Flow` to `Browser with Email OTP`.
   - Save.

4. **Verify Configuration**:
   - Create a test user manually:
     - Go to `Users` > `Add User`.
     - Username: `testuser`, Email: `testuser@example.com`, First Name: `Test`, Last Name: `User`.
     - Save.
     - Go to `Credentials` tab, set password to `password123`, Temporary: `false`.
     - Go to `Role Mappings`, assign `Customer` role.
   - Log in via Keycloak (`http://localhost:8080/realms/salon-realm/account`):
     - Enter `testuser` and `password123`.
     - Check Papercut UI (`http://localhost:8081`) for the OTP email.
     - Enter the OTP to complete login.

---

#### **2. Spring Boot Backend Setup**
We’ll create a Spring Boot microservices architecture with a gateway and a user service for signup.

1. **Project Structure**:
   - **salon-gateway**: Spring Cloud Gateway for routing.
   - **salon-user**: Microservice for user signup and protected APIs.
   - **salon-eureka**: Eureka server for service discovery.

2. **Eureka Server**:
   ```xml
   <!-- salon-eureka/pom.xml -->
   <project>
       <parent>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-parent</artifactId>
           <version>3.3.4</version>
       </parent>
       <groupId>com.salon</groupId>
       <artifactId>salon-eureka</artifactId>
       <version>0.0.1-SNAPSHOT</version>
       <dependencies>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
           </dependency>
       </dependencies>
       <dependencyManagement>
           <dependencies>
               <dependency>
                   <groupId>org.springframework.cloud</groupId>
                   <artifactId>spring-cloud-dependencies</artifactId>
                   <version>2024.0.0</version>
                   <type>pom</type>
                   <scope>import</scope>
               </dependency>
           </dependencies>
       </dependencyManagement>
   </project>
   ```

   ```yaml
   # salon-eureka/src/main/resources/application.yml
   server:
     port: 8070
   spring:
     application:
       name: eureka-server
   eureka:
     client:
       register-with-eureka: false
       fetch-registry: false
   ```

   ```java
   // salon-eureka/src/main/java/com/salon/eureka/EurekaApplication.java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

   @SpringBootApplication
   @EnableEurekaServer
   public class EurekaApplication {
       public static void main(String[] args) {
           SpringApplication.run(EurekaApplication.class, args);
       }
   }
   ```

3. **Gateway Service**:
   ```xml
   <!-- salon-gateway/pom.xml -->
   <project>
       <parent>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-parent</artifactId>
           <version>3.3.4</version>
       </parent>
       <groupId>com.salon</groupId>
       <artifactId>salon-gateway</artifactId>
       <version>0.0.1-SNAPSHOT</version>
       <dependencies>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-gateway</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-security</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
           </dependency>
       </dependencies>
       <dependencyManagement>
           <dependencies>
               <dependency>
                   <groupId>org.springframework.cloud</groupId>
                   <artifactId>spring-cloud-dependencies</artifactId>
                   <version>2024.0.0</version>
                   <type>pom</type>
                   <scope>import</scope>
               </dependency>
           </dependencies>
       </dependencyManagement>
   </project>
   ```

   ```yaml
   # salon-gateway/src/main/resources/application.yml
   server:
     port: 8082
   spring:
     application:
       name: gateway
     cloud:
       gateway:
         routes:
           - id: user-service
             uri: lb://user-service
             predicates:
               - Path=/api/users/**
           - id: protected-service
             uri: lb://user-service
             predicates:
               - Path=/api/protected/**
     security:
       oauth2:
         resourceserver:
           jwt:
             issuer-uri: http://keycloak:8080/realms/salon-realm
   eureka:
     client:
       service-url:
         defaultZone: http://eureka-server:8070/eureka/
   ```

   ```java
   // salon-gateway/src/main/java/com/salon/gateway/GatewayApplication.java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

   @SpringBootApplication
   @EnableEurekaClient
   public class GatewayApplication {
       public static void main(String[] args) {
           SpringApplication.run(GatewayApplication.class, args);
       }
   }
   ```

   ```java
   // salon-gateway/src/main/java/com/salon/gateway/SecurityConfig.java
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.security.config.annotation.web.reactive.EnableWebSecurity;
   import org.springframework.security.config.web.server.ServerHttpSecurity;
   import org.springframework.security.web.server.SecurityWebFilterChain;

   @Configuration
   @EnableWebSecurity
   public class SecurityConfig {

       @Bean
       public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
           http
               .authorizeExchange(exchanges -> exchanges
                   .pathMatchers("/api/users/**").permitAll()
                   .anyExchange().authenticated()
               )
               .oauth2ResourceServer(oauth2 -> oauth2.jwt());
           return http.build();
       }
   }
   ```

4. **User Service (Signup and Protected API)**:
   ```xml
   <!-- salon-user/pom.xml -->
   <project>
       <parent>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-parent</artifactId>
           <version>3.3.4</version>
       </parent>
       <groupId>com.salon</groupId>
       <artifactId>salon-user</artifactId>
       <version>0.0.1-SNAPSHOT</version>
       <dependencies>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-security</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
           </dependency>
           <dependency>
               <groupId>org.keycloak</groupId>
               <artifactId>keycloak-admin-client</artifactId>
               <version>26.0.2</version>
           </dependency>
       </dependencies>
       <dependencyManagement>
           <dependencies>
               <dependency>
                   <groupId>org.springframework.cloud</groupId>
                   <artifactId>spring-cloud-dependencies</artifactId>
                   <version>2024.0.0</version>
                   <type>pom</type>
                   <scope>import</scope>
               </dependency>
           </dependencies>
       </dependencyManagement>
   </project>
   ```

   ```yaml
   # salon-user/src/main/resources/application.yml
   server:
     port: 5001
   spring:
     application:
       name: user-service
     security:
       oauth2:
         resourceserver:
           jwt:
             issuer-uri: http://keycloak:8080/realms/salon-realm
   eureka:
     client:
       service-url:
         defaultZone: http://eureka-server:8070/eureka/
   keycloak:
     server-url: http://keycloak:8080
     realm: salon-realm
     client-id: spring-boot-admin
     client-secret: your-client-secret
   ```

   ```java
   // salon-user/src/main/java/com/salon/user/UserApplication.java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

   @SpringBootApplication
   @EnableEurekaClient
   public class UserApplication {
       public static void main(String[] args) {
           SpringApplication.run(UserApplication.class, args);
       }
   }
   ```

   ```java
   // salon-user/src/main/java/com/salon/user/config/KeycloakConfig.java
   import org.keycloak.admin.client.Keycloak;
   import org.keycloak.admin.client.KeycloakBuilder;
   import org.springframework.beans.factory.annotation.Value;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;

   @Configuration
   public class KeycloakConfig {

       @Value("${keycloak.server-url}")
       private String serverUrl;

       @Value("${keycloak.realm}")
       private String realm;

       @Value("${keycloak.client-id}")
       private String clientId;

       @Value("${keycloak.client-secret}")
       private String clientSecret;

       @Bean
       public Keycloak keycloak() {
           return Key]t with a valid UUID string.
   - **title**: "Keycloak Signup Service"
   - **contentType**: "text/java"
   - **content**:
       ```java
       package com.salon.user.config;

       import org.keycloak.admin.client.Keycloak;
       import org.keycloak.admin.client.KeycloakBuilder;
       import org.springframework.beans.factory.annotation.Value;
       import org.springframework.context.annotation.Bean;
       import org.springframework.context.annotation.Configuration;

       @Configuration
       public class KeycloakConfig {

           @Value("${keycloak.server-url}")
           private String serverUrl;

           @Value("${keycloak.realm}")
           private String realm;

           @Value("${keycloak.client-id}")
           private String clientId;

           @Value("${keycloak.client-secret}")
           private String clientSecret;

           @Bean
           public Keycloak keycloak() {
               return KeycloakBuilder.builder()
                       .serverUrl(serverUrl)
                       .realm(realm)
                       .clientId(clientId)
                       .clientSecret(clientSecret)
                       .grantType("client_credentials")
                       .build();
           }
       }
       ```
   </xaiArtifact>

   ```java
   // salon-user/src/main/java/com/salon/user/service/KeycloakUserService.java
   package com.salon.user.service;

   import org.keycloak.admin.client.Keycloak;
   import org.keycloak.admin.client.resource.RealmResource;
   import org.keycloak.representations.idm.CredentialRepresentation;
   import org.keycloak.representations.idm.RoleRepresentation;
   import org.keycloak.representations.idm.UserRepresentation;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;

   import javax.ws.rs.core.Response;
   import java.util.Collections;

   @Service
   public class KeycloakUserService {

       @Autowired
       private Keycloak keycloak;

       public String createCustomer(String username, String password, String email, String firstName, String lastName) {
           return createUser(username, password, email, firstName, lastName, "Customer");
       }

       public String createSalonOwner(String username, String password, String email, String firstName, String lastName, String salonName) {
           String userId = createUser(username, password, email, firstName, lastName, "Salon Owner");
           // Store salonName in Keycloak user attributes or a separate database
           RealmResource realmResource = keycloak.realm("salon-realm");
           UserRepresentation user = realmResource.users().get(userId).toRepresentation();
           user.getAttributes().put("salonName", Collections.singletonList(salonName));
           realmResource.users().get(userId).update(user);
           return userId;
       }

       private String createUser(String username, String password, String email, String firstName, String lastName, String role) {
           UserRepresentation user = new UserRepresentation();
           user.setUsername(username);
           user.setEmail(email);
           user.setFirstName(firstName);
           user.setLastName(lastName);
           user.setEnabled(true);
           user.setEmailVerified(true);

           CredentialRepresentation credential = new CredentialRepresentation();
           credential.setType(CredentialRepresentation.PASSWORD);
           credential.setValue(password);
           credential.setTemporary(false);
           user.setCredentials(Collections.singletonList(credential));

           RealmResource realmResource = keycloak.realm("salon-realm");
           try (Response response = realmResource.users().create(user)) {
               if (response.getStatus() != 201) {
                   throw new RuntimeException("Failed to create user: " + response.getStatusInfo());
               }
               String userId = response.getLocation().getPath().replaceAll(".*/([^/]+)$", "$1");

               RoleRepresentation roleRepresentation = realmResource.roles().get(role).toRepresentation();
               realmResource.users().get(userId).roles().realmLevel().add(Collections.singletonList(roleRepresentation));

               return userId;
           }
       }
   }
   ```

   ```java
   // salon-user/src/main/java/com/salon/user/controller/UserController.java
   package com.salon.user.controller;

   import com.salon.user.service.KeycloakUserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.PostMapping;
   import org.springframework.web.bind.annotation.RequestBody;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;

   @RestController
   @RequestMapping("/api/users")
   public class UserController {

       @Autowired
       private KeycloakUserService keycloakUserService;

       @PostMapping("/customer")
       public String createCustomer(@RequestBody CustomerDTO customerDTO) {
           return keycloakUserService.createCustomer(
                   customerDTO.getUsername(),
                   customerDTO.getPassword(),
                   customerDTO.getEmail(),
                   customerDTO.getFirstName(),
                   customerDTO.getLastName()
           );
       }

       @PostMapping("/salon-owner")
       public String createSalonOwner(@RequestBody SalonOwnerDTO salonOwnerDTO) {
           return keycloakUserService.createSalonOwner(
                   salonOwnerDTO.getUsername(),
                   salonOwnerDTO.getPassword(),
                   salonOwnerDTO.getEmail(),
                   salonOwnerDTO.getFirstName(),
                   salonOwnerDTO.getLastName(),
                   salonOwnerDTO.getSalonName()
           );
       }
   }

   class CustomerDTO {
       private String username;
       private String password;
       private String email;
       private String firstName;
       private String lastName;

       // Getters and setters
       public String getUsername() { return username; }
       public void setUsername(String username) { this.username = username; }
       public String getPassword() { return password; }
       public void setPassword(String password) { this.password = password; }
       public String getEmail() { return email; }
       public void setEmail(String email) { this.email = email; }
       public String getFirstName() { return firstName; }
       public void setFirstName(String firstName) { this.firstName = firstName; }
       public String getLastName() { return lastName; }
       public void setLastName(String lastName) { this.lastName = lastName; }
   }

   class SalonOwnerDTO extends CustomerDTO {
       private String salonName;

       // Getter and setter
       public String getSalonName() { return salonName; }
       public void setSalonName(String salonName) { this.salonName = salonName; }
   }
   ```

   ```java
   // salon-user/src/main/java/com/salon/user/controller/ProtectedController.java
   package com.salon.user.controller;

   import org.springframework.security.core.annotation.AuthenticationPrincipal;
   import org.springframework.security.oauth2.jwt.Jwt;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;

   @RestController
   @RequestMapping("/api/protected")
   public class ProtectedController {

       @GetMapping
       public String protectedEndpoint(@AuthenticationPrincipal Jwt jwt) {
           return "Hello, " + jwt.getClaim("preferred_username") + "! Role: " + jwt.getClaim("roles");
       }
   }
   ```

5. **Docker Compose**:
   ```yaml
   # docker-compose.yml
   services:
     keycloak:
       image: quay.io/keycloak/keycloak:26.0.2
       environment:
         KEYCLOAK_ADMIN: admin
         KEYCLOAK_ADMIN_PASSWORD: admin
       ports:
         - "8080:8080"
       command: start-dev
       networks:
         - salon-network
     papercut:
       image: jijiechen/papercut:latest
       ports:
         - "8081:8080"
         - "25:25"
       networks:
         - salon-network
     eureka-server:
       image: salon-eureka:0.0.1-SNAPSHOT
       ports:
         - "8070:8070"
       networks:
         - salon-network
     gateway:
       image: salon-gateway:0.0.1-SNAPSHOT
       ports:
         - "8082:8082"
       depends_on:
         - eureka-server
         - keycloak
       networks:
         - salon-network
     user-service:
       image: salon-user:0.0.1-SNAPSHOT
       ports:
         - "5001:5001"
       depends_on:
         - eureka-server
         - keycloak
       networks:
         - salon-network
     react-app:
       image: node:18
       working_dir: /app
       volumes:
         - ./react-app:/app
       ports:
         - "3000:3000"
       command: sh -c "npm install && npm run dev"
       networks:
         - salon-network
   networks:
     salon-network:
       driver: bridge
   ```

---

#### **3. React Frontend Setup**
We’ll create a React app using Vite, Material UI, and Tailwind CSS, with a modular structure and role-based UI.

1. **Create React App**:
   ```bash
   npm create vite@latest react-app -- --template react-ts
   cd react-app
   npm install
   ```

2. **Install Dependencies**:
   ```bash
   npm install @mui/material @emotion/react @emotion/styled @mui/icons-material axios oidc-client-ts react-router-dom tailwindcss postcss autoprefixer
   npx tailwindcss init -p
   ```

3. **Configure Tailwind CSS**:
   ```javascript
   // react-app/tailwind.config.js
   /** @type {import('tailwindcss').Config} */
   export default {
     content: [
       "./index.html",
       "./src/**/*.{js,ts,jsx,tsx}",
     ],
     theme: {
       extend: {},
     },
     plugins: [],
   }
   ```

   ```css
   /* react-app/src/index.css */
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   ```

4. **Project Structure**:
   ```
   react-app/
   ├── src/
   │   ├── assets/
   │   ├── components/
   │   │   ├── CustomerSignupForm.tsx
   │   │   ├── SalonOwnerSignupForm.tsx
   │   │   ├── AdminPanel.tsx
   │   │   ├── SalonOwnerPanel.tsx
   │   │   ├── CustomerPanel.tsx
   │   ├── context/
   │   │   ├── AuthContext.tsx
   │   ├── pages/
   │   │   ├── Home.tsx
   │   │   ├── Callback.tsx
   │   ├── App.tsx
   │   ├── index.css
   │   ├── main.tsx
   ├── tailwind.config.js
   ├── vite.config.ts
   ├── package.json
   ```

5. **React Code**:
   ```tsx
   // react-app/src/main.tsx
   import React from 'react';
   import ReactDOM from 'react-dom/client';
   import { BrowserRouter } from 'react-router-dom';
   import App from './App.tsx';
   import './index.css';
   import { AuthProvider } from './context/AuthContext.tsx';

   ReactDOM.createRoot(document.getElementById('root')!).render(
     <React.StrictMode>
       <BrowserRouter>
         <AuthProvider>
           <App />
         </AuthProvider>
       </BrowserRouter>
     </React.StrictMode>,
   );
   ```

   ```tsx
   // react-app/src/App.tsx
   import { Routes, Route } from 'react-router-dom';
   import Home from './pages/Home';
   import Callback from './pages/Callback';
   import { AuthContext } from './context/AuthContext';
   import { useContext } from 'react';
   import AdminPanel from './components/AdminPanel';
   import SalonOwnerPanel from './components/SalonOwnerPanel';
   import CustomerPanel from './components/CustomerPanel';

   function App() {
     const { user, loading } = useContext(AuthContext);

     if (loading) return <div>Loading...</div>;

     return (
       <Routes>
         <Route path="/" element={<Home />} />
         <Route path="/callback" element={<Callback />} />
         <Route
           path="/admin"
           element={user?.roles?.includes('Admin') ? <AdminPanel /> : <div>Unauthorized</div>}
         />
         <Route
           path="/salon-owner"
           element={user?.roles?.includes('Salon Owner') ? <SalonOwnerPanel /> : <div>Unauthorized</div>}
         />
         <Route
           path="/customer"
           element={user?.roles?.includes('Customer') ? <CustomerPanel /> : <div>Unauthorized</div>}
         />
       </Routes>
     );
   }

   export default App;
   ```

   ```tsx
   // react-app/src/context/AuthContext.tsx
   import React, { createContext, useEffect, useState } from 'react';
   import { UserManager, WebStorageStateStore } from 'oidc-client-ts';

   interface AuthContextType {
     user: any | null;
     login: () => void;
     logout: () => void;
     getToken: () => string | null;
     loading: boolean;
   }

   export const AuthContext = createContext<AuthContextType | undefined>(undefined);

   const userManager = new UserManager({
     authority: 'http://localhost:8080/realms/salon-realm',
     client_id: 'react-app',
     redirect_uri: 'http://localhost:3000/callback',
     response_type: 'code',
     scope: 'openid profile email roles',
     post_logout_redirect_uri: 'http://localhost:3000',
     automaticSilentRenew: true,
     userStore: new WebStorageStateStore({ store: window.localStorage }),
   });

   export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
     const [user, setUser] = useState<any | null>(null);
     const [loading, setLoading] = useState(true);

     useEffect(() => {
       userManager.getUser().then((user) => {
         setUser(user);
         setLoading(false);
       });

       userManager.events.addUserLoaded((user) => setUser(user));
       userManager.events.addUserUnloaded(() => setUser(null));
       userManager.events.addAccessTokenExpired(() => userManager.signinRedirect());
     }, []);

     const login = () => userManager.signinRedirect();
     const logout = () => userManager.signoutRedirect();
     const getToken = () => user?.access_token || null;

     return (
       <AuthContext.Provider value={{ user, login, logout, getToken, loading }}>
         {children}
       </AuthContext.Provider>
     );
   };
   ```

   ```tsx
   // react-app/src/pages/Home.tsx
   import { useContext } from 'react';
   import { AuthContext } from '../context/AuthContext';
   import CustomerSignupForm from '../components/CustomerSignupForm';
   import SalonOwnerSignupForm from '../components/SalonOwnerSignupForm';
   import { Button } from '@mui/material';

   const Home: React.FC = () => {
     const { user, login } = useContext(AuthContext);

     return (
       <div className="p-4">
         <h1 className="text-3xl font-bold">Salon App</h1>
         {user ? (
           <div>
             <p>Welcome, {user.profile.preferred_username}!</p>
             <Button variant="contained" onClick={() => window.location.href = user.roles.includes('Admin') ? '/admin' : user.roles.includes('Salon Owner') ? '/salon-owner' : '/customer'}>
               Go to Dashboard
             </Button>
           </div>
         ) : (
           <div>
             <Button variant="contained" onClick={login} className="mb-4">
               Login
             </Button>
             <CustomerSignupForm />
             <SalonOwnerSignupForm />
           </div>
         )}
       </div>
     );
   };

   export default Home;
   ```

   ```tsx
   // react-app/src/pages/Callback.tsx
   import { useEffect } from 'react';
   import { useNavigate } from 'react-router-dom';
   import { userManager } from '../context/AuthContext';

   const Callback: React.FC = () => {
     const navigate = useNavigate();

     useEffect(() => {
       userManager.signinRedirectCallback().then(() => {
         navigate('/');
       }).catch((err) => {
         console.error('Callback error:', err);
         navigate('/error');
       });
     }, [navigate]);

     return <div>Loading...</div>;
   };

   export default Callback;
   ```

   ```tsx
   // react-app/src/components/CustomerSignupForm.tsx
   import { useState } from 'react';
   import { TextField, Button } from '@mui/material';
   import axios from 'axios';

   const CustomerSignupForm: React.FC = () => {
     const [formData, setFormData] = useState({
       username: '',
       password: '',
       email: '',
       firstName: '',
       lastName: '',
     });

     const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
       setFormData({ ...formData, [e.target.name]: e.target.value });
     };

     const handleSubmit = async (e: React.FormEvent) => {
       e.preventDefault();
       try {
         await axios.post('http://localhost:8082/api/users/customer', formData);
         alert('Customer created successfully');
       } catch (error) {
         console.error('Signup error:', error);
         alert('Failed to create customer');
       }
     };

     return (
       <form onSubmit={handleSubmit} className="mt-4 space-y-4">
         <h2 className="text-xl font-semibold">Customer Signup</h2>
         <TextField label="Username" name="username" value={formData.username} onChange={handleChange} fullWidth />
         <TextField label="Password" name="password" type="password" value={formData.password} onChange={handleChange} fullWidth />
         <TextField label="Email" name="email" type="email" value={formData.email} onChange={handleChange} fullWidth />
         <TextField label="First Name" name="firstName" value={formData.firstName} onChange={handleChange} fullWidth />
         <TextField label="Last Name" name="lastName" value={formData.lastName} onChange={handleChange} fullWidth />
         <Button type="submit" variant="contained">Sign Up</Button>
       </form>
     );
   };

   export default CustomerSignupForm;
   ```

   ```tsx
   // react-app/src/components/SalonOwnerSignupForm.tsx
   import { useState } from 'react';
   import { TextField, Button } from '@mui/material';
   import axios from 'axios';

   const SalonOwnerSignupForm: React.FC = () => {
     const [formData, setFormData] = useState({
       username: '',
       password: '',
       email: '',
       firstName: '',
       lastName: '',
       salonName: '',
     });

     const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
       setFormData({ ...formData, [e.target.name]: e.target.value });
     };

     const handleSubmit = async (e: React.FormEvent) => {
       e.preventDefault();
       try {
         await axios.post('http://localhost:8082/api/users/salon-owner', formData);
         alert('Salon Owner created successfully');
       } catch (error) {
         console.error('Signup error:', error);
         alert('Failed to create salon owner');
       }
     };

     return (
       <form onSubmit={handleSubmit} className="mt-4 space-y-4">
         <h2 className="text-xl font-semibold">Salon Owner Signup</h2>
         <TextField label="Username" name="username" value={formData.username} onChange={handleChange} fullWidth />
         <TextField label="Password" name="password" type="password" value={formData.password} onChange={handleChange} fullWidth />
         <TextField label="Email" name="email" type="email" value={formData.email} onChange={handleChange} fullWidth />
         <TextField label="First Name" name="firstName" value={formData.firstName} onChange={handleChange} fullWidth />
         <TextField label="Last Name" name="lastName" value={formData.lastName} onChange={handleChange} fullWidth />
         <TextField label="Salon Name" name="salonName" value={formData.salonName} onChange={handleChange} fullWidth />
         <Button type="submit" variant="contained">Sign Up</Button>
       </form>
     );
   };

   export default SalonOwnerSignupForm;
   ```

   ```tsx
   // react-app/src/components/AdminPanel.tsx
   import { Button } from '@mui/material';

   const AdminPanel: React.FC = () => {
     return (
       <div className="p-4">
         <h1 className="text-2xl font-bold">Admin Panel</h1>
         <p>Manage admin-related data here.</p>
         <Button variant="contained">Perform Admin Action</Button>
       </div>
     );
   };

   export default AdminPanel;
   ```

   ```tsx
   // react-app/src/components/SalonOwnerPanel.tsx
   import { Button } from '@mui/material';

   const SalonOwnerPanel: React.FC = () => {
     return (
       <div className="p-4">
         <h1 className="text-2xl font-bold">Salon Owner Panel</h1>
         <p>Manage categories and services for your salon.</p>
         <Button variant="contained">Add Category</Button>
         <Button variant="contained" className="ml-2">Add Service</Button>
       </div>
     );
   };

   export default SalonOwnerPanel;
   ```

   ```tsx
   // react-app/src/components/CustomerPanel.tsx
   import { Button } from '@mui/material';

   const CustomerPanel: React.FC = () => {
     return (
       <div className="p-4">
         <h1 className="text-2xl font-bold">Customer Panel</h1>
         <p>Search salons and book services.</p>
         <Button variant="contained">Search Salons</Button>
         <Button variant="contained" className="ml-2">Book Service</Button>
       </div>
     );
   };

   export default CustomerPanel;
   ```

6. **ESLint and Prettier**:
   ```bash
   npm install --save-dev eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks
   npx eslint --init
   ```

   ```javascript
   // react-app/.eslintrc.js
   module.exports = {
     env: {
       browser: true,
       es2021: true,
     },
     extends: [
       'eslint:recommended',
       'plugin:react/recommended',
       'plugin:react-hooks/recommended',
       'plugin:prettier/recommended',
     ],
     parserOptions: {
       ecmaVersion: 12,
       sourceType: 'module',
     },
     plugins: ['react', 'react-hooks', 'prettier'],
     rules: {
       'prettier/prettier': 'error',
       'react/prop-types': 'off',
     },
   };
   ```

   ```json
   // react-app/.prettierrc
   {
     "semi": true,
     "trailingComma": "es5",
     "singleQuote": true,
     "printWidth": 80,
     "tabWidth": 2,
     "useTabs": false,
     "bracketSpacing": true
   }
   ```

---

#### **4. Testing the Application**
1. **Build and Run**:
   ```bash
   # Build Spring Boot services
   cd salon-eureka && mvn clean install
   cd ../salon-gateway && mvn clean install
   cd ../salon-user && mvn clean install

   # Start Docker Compose
   docker-compose up
   ```

2. **Access Services**:
   - Keycloak: `http://localhost:8080`
   - Papercut: `http://localhost:8081`
   - Eureka: `http://localhost:8070`
   - Gateway: `http://localhost:8082`
   - User Service: `http://localhost:5001`
   - React App: `http://localhost:3000`

3. **Test Signup**:
   - Open `http://localhost:3000`.
   - Fill out the Customer or Salon Owner signup form.
   - Verify the user is created in Keycloak (`http://localhost:8080/admin`).

4. **Test Login**:
   - Click “Login” on the React app.
   - Enter credentials and receive an OTP via Papercut (`http://localhost:8081`).
   - Enter the OTP to complete login.
   - Verify redirection to the appropriate panel (Admin, Salon Owner, or Customer).

5. **Test Protected API**:
   - After login, navigate to the respective panel and call a protected API (e.g., `http://localhost:8082/api/protected`).
   - Verify the response includes the username and role.

---

### **Security and Best Practices**
1. **Backend**:
   - Use HTTPS in production.
   - Validate and sanitize input in `UserController`.
   - Implement rate limiting on signup endpoints.
   - Store `client-secret` in environment variables or a vault.

2. **Frontend**:
   - Use in-memory token storage or `HttpOnly` cookies instead of `localStorage`.
   - Implement XSS protection (e.g., sanitize inputs in forms).
   - Use TypeScript for type safety.
   - Follow React best practices (functional components, hooks, memoization).

3. **Keycloak**:
   - Rotate client secrets regularly.
   - Configure session timeouts and token lifespans appropriately.
   - Enable MFA for all users.

4. **Docker**:
   - Use multi-stage builds for smaller images.
   - Secure Docker network with proper access controls.

---

### **References**
- Keycloak Documentation: https://www.keycloak.org/docs/26.0.2/
- Spring Boot Documentation: https://spring.io/projects/spring-boot
- React Documentation: https://react.dev/
- Vite Documentation: https://vitejs.dev/
- Material UI Documentation: https://mui.com/
- Tailwind CSS Documentation: https://tailwindcss.com/

---

This setup provides a complete, industry-standard solution for your salon app. You can extend the signup forms, panels, and APIs as needed. If you encounter issues or need additional features (e.g., database integration, specific API endpoints), let me know, and I’ll provide further assistance!